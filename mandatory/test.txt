/* 
    Ray intersection
    Returns the t value where the ray intersects the cylinder
    If there is no intersection, it returns -1
*/
double Cylinder::rayIntersection(Ray &ray)
{
    //Check the intersection with the upper plane
    double dotP1 = dir.dot(ray.getDir());
    if(dotP1 < 0)
    {
        double d1 = -(dir.dot(a));
        double t1 = -(d1 + dir.dot(ray.getOrigin()))/dotP1;
        Vector3 p1 = ray.getPoint(t1);

        if((p1-a).magnitudeSquared() <= r*r)
            return t1;
    }
    //Check the intersection with the lower plane
    double dotP2 = (-dir).dot(ray.getDir());
    if(dotP2 < 0)
    { 
        double d2 = -((-dir).dot(b));
        double t2 = -(d2 + (-dir).dot(ray.getOrigin()))/dotP2;
        Vector3 p2 = ray.getPoint(t2);

        if((p2-b).magnitudeSquared() <= r*r)
            return t2;
    }

    //Check the intersection with the torso
    Vector3 AB = (b - a);
    Vector3 AO = (ray.getOrigin() - a);
    Vector3 AOxAB = (AO.cross(AB));
    Vector3 VxAB = (ray.getDir().cross(AB));
    double ab2 = (AB.dot(AB));
    double A = (VxAB.dot(VxAB));
    double B = 2 * (VxAB.dot(AOxAB));
    double C = (AOxAB.dot(AOxAB)) - (r*r * ab2);

    double discr = B*B-4*A*C;

    if(discr<0)return -1;

    double t1 = (-B + sqrt(discr))/(2*A);
    double t2 = (-B - sqrt(discr))/(2*A);

    double t = (t1 < t2)?t1:t2;
    if(t < 0)
        t = (t1 > t2)?t1:t2;

    if(t>=0)
    {
        Vector3 point = ray.getPoint(t);
        double dotA = (point-a).dot(dir);
        double dotB = (point-b).dot(-dir);
        if(dotA > 0 || dotB > 0)
            t = -1;
    }

    //Return the smallest t greater than 0, because it was the first intersection
    return t;
}




static double intersect_plane(t_plane *plane, t_ray *ray)
{
	double		root;
	double		denominator;
	double		num;
	t_vector	vec;

	denominator = dot_product(&ray->direction, &plane->normal);
	if (denominator > 1e-6)
	{
		subtraction(&vec, &plane->point, &ray->origin);
		num = dot_product(&vec, &plane->normal);
		root =  num / denominator;
		if (root >= 0)
			return (root);
	}
	return (NAN);
}

static double intersect_disk(t_cylinder *cy, t_ray *ray, int direction)
{
	t_plane		plane;
	t_vector	vec;
	t_vector	intersect;
	double		t;
	double		t_len;

	unit_vector(&vec, &cy->normal);
	multiply_scalar(&vec, &vec,(cy->height / 2) * direction);
	addition(&plane.point, &vec, &cy->center);
	plane.normal = cy->normal;
	t = intersect_plane(&plane, ray);
	if (isnan(t))
		return (NAN);
	unit_vector(&intersect, &ray->direction);
	multiply_scalar(&intersect, &intersect, t);
	addition(&intersect, &intersect, &ray->origin);
	subtraction(&intersect, &intersect, &plane.point);
	t_len = length_sqrd(&intersect);
	if (sqrt(t_len) <= cy->radius)
		return (t);
	return (NAN);
}

static bool	hit_point(t_objlst *objects, t_ray *ray, t_record *record,
					double root)
{
	t_cylinder	*cylinder;
	t_vector	temp;
	double		point;
	double		top;
	double		btm;
	double		t;

	cylinder = (t_cylinder *)objects->object;
	t = -1;
	top = intersect_disk(cylinder, ray, 1);
	btm = intersect_disk(cylinder, ray, -1);
	if (isnan(root) == false)
	{
		ray_at(&record->point, ray, root);
		subtraction(&temp, &record->point, &cylinder->center);
		point = dot_product(&temp, &cylinder->normal);
		if (point > cylinder->height / 2 || point < 0)
			root = NAN;
	}
	if (isnan(top) == false && top < t)
		t = top;
	if (isnan(btm) == false && btm < t)
		t = btm;
	if (isnan(root) == false && root < t)
		t = root;
	if (t > record->tmax || t < record->tmin)
		return (false);
	record->t = t;
	subtraction(&record->normal, &record->point, &cylinder->center);
	multiply_scalar(&record->normal, &record->normal,
		dot_product(&record->normal, &cylinder->normal));
	addition(&record->normal, &record->normal, &cylinder->center);
	subtraction(&record->normal, &record->point, &record->normal);
	unit_vector(&record->normal, &record->normal);
	set_face_normal(ray, record);
	record->color = objects->color;
	return (true);
}

static void	*intersection(t_equation *eq, t_objlst *objects, t_ray *ray)
{
	t_cylinder	*cylinder;
	t_vector	oc;
	double		dot_ray_cy;
	double		dot_oc_cy;

	cylinder = (t_cylinder *)objects->object;
	subtraction(&oc, &ray->origin, &cylinder->center);
	dot_ray_cy = dot_product(&ray->direction, &cylinder->normal);
	dot_oc_cy = dot_product(&oc, &cylinder->normal);
	eq->a = length_sqrd(&ray->direction) - (dot_ray_cy * dot_ray_cy);
	eq->half_b = dot_product(&ray->direction, &oc) - (dot_ray_cy * dot_oc_cy);
	eq->c = length_sqrd(&oc) - cylinder->radius2 - (dot_oc_cy * dot_oc_cy);
	return (eq);
}

bool	hit_cylinder(t_objlst *objects, t_ray *ray, t_record *record)
{
	t_equation	eq;

	intersection(&eq, objects, ray);
	if (hit_point(objects, ray, record, nearest_root(&eq, 0)))
		return (true);
	if (hit_point(objects, ray, record, nearest_root(&eq, 1)))
		return (true);
	return (false);
}


static double	root_rectangle(t_cylinder *cy, t_ray r, double lim)
{
	t_vec3	v;
	double	a;
	double	h_b;
	double	c;
	double	t;

	v = sub(r.p, cy->p);
	a = len_pow(cross(r.o, cy->o));
	h_b = dot(cross(r.o, cy->o), cross(v, cy->o));
	c = len_pow(cross(v, cy->o)) - cy->r * cy->r;
	if (h_b * h_b - a * c < 0)
		return (INFINITY);
	t = (-h_b - sqrt(h_b * h_b - a * c)) / a;
	if (t < 0.001 || t > lim)
	{
		t = (-h_b + sqrt(h_b * h_b - a * c)) / a;
		if (t < 0.001 || t > lim)
			return (INFINITY);
	}
	if (dot(cy->o, sub(add(r.p, scale(r.o, t)), cy->tc)) > 0)
		return (INFINITY);
	if (dot(cy->o, sub(add(r.p, scale(r.o, t)), cy->bc)) < 0)
		return (INFINITY);
	return (t);
}

_vec3	scale(t_vec3 v, double s)
{
	return (v_init((v.x * s), (v.y * s), (v.z * s)));
}
static double	root_circle(t_cylinder *cy, t_ray r, double lim)
{
	t_vec3	tv;
	t_vec3	bv;
	double	denom;
	double	tt;
	double	bt;

	denom = dot(r.o, cy->o);
	if (!denom)
		return (INFINITY);
	tv = sub(cy->tc, r.p);
	tt = dot(tv, cy->o) / denom;
	if (len_pow(sub(add(r.p, scale(r.o, tt)), cy->tc)) > cy->r * cy->r)
		tt = INFINITY;
	bv = sub(cy->bc, r.p);
	bt = dot(bv, cy->o) / denom;
	if (len_pow(sub(add(r.p, scale(r.o, bt)), cy->bc)) > cy->r * cy->r)
		bt = INFINITY;
	if (tt < 0.001 || tt > lim)
		tt = INFINITY;
	if (bt < 0.001 || bt > lim)
		bt = INFINITY;
	if (tt < bt)
		return (tt);
	return (bt);
}

t_bool			hit_cy(t_obj obj, t_ray r, double lim, t_hit *rec)
{
	t_cylinder	*cy;
	double		r_t;
	double		c_t;

	if (obj.type != CYLINDER)
		return (FALSE);
	cy = (t_cylinder *)(obj.data);
	r_t = root_rectangle(cy, r, lim);
	c_t = root_circle(cy, r, lim);
	if (r_t == INFINITY && c_t == INFINITY)
		return (FALSE);
	if (r_t < c_t)
	{
		set_hit_point(r, r_t, rec);
		set_normal(obj, r, unit(sub(rec->p, add(scale(cy->o,
			dot(cy->o, sub(rec->p, cy->p))), cy->p))), rec);
	}
	else
	{
		set_hit_point(r, c_t, rec);
		set_normal(obj, r, cy->o, rec);
	}
	set_hit_color(cy->c, obj.filter, rec);
	return (TRUE);
}



static t_bool	cy_boundary(t_cylinder *cy, t_vec3 at_point, double *hit_height)
{
	*hit_height = vdot(vminus(at_point, cy->center), cy->dir);
	if (*hit_height > cy->height || *hit_height < 0)
		return (FALSE);
	return (TRUE);
}

static t_vec3	get_cylinder_normal(t_cylinder *cy, t_vec3 at_point,
	double hit_height)
{
	t_point3	hit_center;
	t_vec3		normal;

	hit_center = vplus(cy->center, vmult(cy->dir, hit_height));
	normal = vminus(at_point, hit_center);
	return (vunit(normal));
}

static t_disc	calc_cy_disc(t_cylinder *cy, t_ray *ray)
{
	t_disc	disc;
	t_vec3	oc;

	oc = vminus(ray->orig, cy->center);
	disc.a = vlength2(vcross(ray->dir, cy->dir));
	disc.half_b = vdot(vcross(ray->dir, cy->dir), vcross(oc, cy->dir));
	disc.c = vlength2(vcross(oc, cy->dir)) - pow(cy->radius, 2);
	disc.discriminant = disc.half_b * disc.half_b - disc.a * disc.c;
	return (disc);
}

static double	calc_root(t_disc disc, double sqrtd, double tmin, double tmax)
{
	double	root;

	root = (-disc.half_b - sqrtd) / disc.a;
	if (root < tmin || tmax < root)
	{
		root = (-disc.half_b + sqrtd) / disc.a;
		if (root < tmin || tmax < root)
			return (0);
	}
	return (root);
}

int	hit_cylinder(t_object *cy_obj, t_ray *ray, t_hit_record *rec)
{
	t_cylinder	*cy;
	t_disc		disc;
	double		sqrtd;
	double		root;
	double		hit_height;

	cy = cy_obj->element;
	disc = calc_cy_disc(cy, ray);
	if (disc.discriminant < 0)
		return (0);
	sqrtd = sqrt(disc.discriminant);
	root = calc_root(disc, sqrtd, rec->tmin, rec->tmax);
	if (root == 0)
		return (0);
	if (!(cy_boundary(cy, ray_at(ray, root), &hit_height)))
		return (0);
	rec->t = root;
	rec->p = ray_at(ray, root);
	rec->normal = get_cylinder_normal(cy, rec->p, hit_height);
	set_face_normal(ray, rec);
	rec->albedo = cy_obj->albedo;
	return (1);
}